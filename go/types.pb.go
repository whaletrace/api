// Code generated by protoc-gen-go. DO NOT EDIT.
// source: types.proto

/*
Package types is a generated protocol buffer package.

It is generated from these files:
	types.proto

It has these top-level messages:
	Transaction
	Entity
	Token
	Empty
	CryptoSubscribeRequest
	TransactionResponse
	CryptoTransactionRequest
*/
package types

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/timestamp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// *
// Represents information about a transaction that occured
type Transaction struct {
	Hash    string                     `protobuf:"bytes,2,opt,name=hash" json:"hash,omitempty"`
	From    *Entity                    `protobuf:"bytes,3,opt,name=from" json:"from,omitempty"`
	To      *Entity                    `protobuf:"bytes,4,opt,name=to" json:"to,omitempty"`
	Time    *google_protobuf.Timestamp `protobuf:"bytes,7,opt,name=time" json:"time,omitempty"`
	Asset   string                     `protobuf:"bytes,9,opt,name=asset" json:"asset,omitempty"`
	Size    float64                    `protobuf:"fixed64,10,opt,name=size" json:"size,omitempty"`
	USDSize float64                    `protobuf:"fixed64,11,opt,name=USD_size,json=USDSize" json:"USD_size,omitempty"`
	Token   *Token                     `protobuf:"bytes,12,opt,name=token" json:"token,omitempty"`
}

func (m *Transaction) Reset()                    { *m = Transaction{} }
func (m *Transaction) String() string            { return proto.CompactTextString(m) }
func (*Transaction) ProtoMessage()               {}
func (*Transaction) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Transaction) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *Transaction) GetFrom() *Entity {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *Transaction) GetTo() *Entity {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *Transaction) GetTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *Transaction) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

func (m *Transaction) GetSize() float64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *Transaction) GetUSDSize() float64 {
	if m != nil {
		return m.USDSize
	}
	return 0
}

func (m *Transaction) GetToken() *Token {
	if m != nil {
		return m.Token
	}
	return nil
}

// *
// Represents additional information about an entity thet receved/sent transaction
type Entity struct {
	Address string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	Name    string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Type    string `protobuf:"bytes,3,opt,name=type" json:"type,omitempty"`
	Url     string `protobuf:"bytes,4,opt,name=url" json:"url,omitempty"`
}

func (m *Entity) Reset()                    { *m = Entity{} }
func (m *Entity) String() string            { return proto.CompactTextString(m) }
func (*Entity) ProtoMessage()               {}
func (*Entity) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Entity) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Entity) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Entity) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Entity) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// *
// Extends basic transaction data with information about token transaction
type Token struct {
	Name   string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Chain  string `protobuf:"bytes,2,opt,name=chain" json:"chain,omitempty"`
	Symbol string `protobuf:"bytes,3,opt,name=symbol" json:"symbol,omitempty"`
	Action string `protobuf:"bytes,4,opt,name=action" json:"action,omitempty"`
}

func (m *Token) Reset()                    { *m = Token{} }
func (m *Token) String() string            { return proto.CompactTextString(m) }
func (*Token) ProtoMessage()               {}
func (*Token) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Token) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Token) GetChain() string {
	if m != nil {
		return m.Chain
	}
	return ""
}

func (m *Token) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *Token) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

// *
// Empty message
type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// *
// Represents data of request for crypto transactions of some type(Asset), with optional sizeLimit filter
type CryptoSubscribeRequest struct {
	Type      string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	SizeLimit int64  `protobuf:"varint,5,opt,name=sizeLimit" json:"sizeLimit,omitempty"`
}

func (m *CryptoSubscribeRequest) Reset()                    { *m = CryptoSubscribeRequest{} }
func (m *CryptoSubscribeRequest) String() string            { return proto.CompactTextString(m) }
func (*CryptoSubscribeRequest) ProtoMessage()               {}
func (*CryptoSubscribeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *CryptoSubscribeRequest) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *CryptoSubscribeRequest) GetSizeLimit() int64 {
	if m != nil {
		return m.SizeLimit
	}
	return 0
}

// *
// Respresent stream of transaction chunked into an array
type TransactionResponse struct {
	Data []*Transaction `protobuf:"bytes,1,rep,name=data" json:"data,omitempty"`
}

func (m *TransactionResponse) Reset()                    { *m = TransactionResponse{} }
func (m *TransactionResponse) String() string            { return proto.CompactTextString(m) }
func (*TransactionResponse) ProtoMessage()               {}
func (*TransactionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *TransactionResponse) GetData() []*Transaction {
	if m != nil {
		return m.Data
	}
	return nil
}

// *
// Represents data of request for crypto transactions of some type(Asset) with additional filters
type CryptoTransactionRequest struct {
	Type      string                     `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	From      *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=from" json:"from,omitempty"`
	To        *google_protobuf.Timestamp `protobuf:"bytes,3,opt,name=to" json:"to,omitempty"`
	Count     int64                      `protobuf:"varint,4,opt,name=count" json:"count,omitempty"`
	SizeLimit int64                      `protobuf:"varint,5,opt,name=sizeLimit" json:"sizeLimit,omitempty"`
}

func (m *CryptoTransactionRequest) Reset()                    { *m = CryptoTransactionRequest{} }
func (m *CryptoTransactionRequest) String() string            { return proto.CompactTextString(m) }
func (*CryptoTransactionRequest) ProtoMessage()               {}
func (*CryptoTransactionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *CryptoTransactionRequest) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *CryptoTransactionRequest) GetFrom() *google_protobuf.Timestamp {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *CryptoTransactionRequest) GetTo() *google_protobuf.Timestamp {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *CryptoTransactionRequest) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *CryptoTransactionRequest) GetSizeLimit() int64 {
	if m != nil {
		return m.SizeLimit
	}
	return 0
}

func init() {
	proto.RegisterType((*Transaction)(nil), "types.Transaction")
	proto.RegisterType((*Entity)(nil), "types.Entity")
	proto.RegisterType((*Token)(nil), "types.Token")
	proto.RegisterType((*Empty)(nil), "types.Empty")
	proto.RegisterType((*CryptoSubscribeRequest)(nil), "types.CryptoSubscribeRequest")
	proto.RegisterType((*TransactionResponse)(nil), "types.TransactionResponse")
	proto.RegisterType((*CryptoTransactionRequest)(nil), "types.CryptoTransactionRequest")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for TransactionServer service

type TransactionServerClient interface {
	// Obtain top transaction from given time-frame of given asset as an rpc stream
	TopTransactions(ctx context.Context, in *CryptoTransactionRequest, opts ...grpc.CallOption) (TransactionServer_TopTransactionsClient, error)
	// Obtain historic transactions from given time-frame of given asset as an array
	HistoricTransactions(ctx context.Context, in *CryptoTransactionRequest, opts ...grpc.CallOption) (TransactionServer_HistoricTransactionsClient, error)
	// subscribe to the newest transactions of given asset
	SubscribeTransactions(ctx context.Context, in *CryptoSubscribeRequest, opts ...grpc.CallOption) (TransactionServer_SubscribeTransactionsClient, error)
}

type transactionServerClient struct {
	cc *grpc.ClientConn
}

func NewTransactionServerClient(cc *grpc.ClientConn) TransactionServerClient {
	return &transactionServerClient{cc}
}

func (c *transactionServerClient) TopTransactions(ctx context.Context, in *CryptoTransactionRequest, opts ...grpc.CallOption) (TransactionServer_TopTransactionsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_TransactionServer_serviceDesc.Streams[0], c.cc, "/types.TransactionServer/TopTransactions", opts...)
	if err != nil {
		return nil, err
	}
	x := &transactionServerTopTransactionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TransactionServer_TopTransactionsClient interface {
	Recv() (*Transaction, error)
	grpc.ClientStream
}

type transactionServerTopTransactionsClient struct {
	grpc.ClientStream
}

func (x *transactionServerTopTransactionsClient) Recv() (*Transaction, error) {
	m := new(Transaction)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *transactionServerClient) HistoricTransactions(ctx context.Context, in *CryptoTransactionRequest, opts ...grpc.CallOption) (TransactionServer_HistoricTransactionsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_TransactionServer_serviceDesc.Streams[1], c.cc, "/types.TransactionServer/HistoricTransactions", opts...)
	if err != nil {
		return nil, err
	}
	x := &transactionServerHistoricTransactionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TransactionServer_HistoricTransactionsClient interface {
	Recv() (*Transaction, error)
	grpc.ClientStream
}

type transactionServerHistoricTransactionsClient struct {
	grpc.ClientStream
}

func (x *transactionServerHistoricTransactionsClient) Recv() (*Transaction, error) {
	m := new(Transaction)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *transactionServerClient) SubscribeTransactions(ctx context.Context, in *CryptoSubscribeRequest, opts ...grpc.CallOption) (TransactionServer_SubscribeTransactionsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_TransactionServer_serviceDesc.Streams[2], c.cc, "/types.TransactionServer/SubscribeTransactions", opts...)
	if err != nil {
		return nil, err
	}
	x := &transactionServerSubscribeTransactionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TransactionServer_SubscribeTransactionsClient interface {
	Recv() (*Transaction, error)
	grpc.ClientStream
}

type transactionServerSubscribeTransactionsClient struct {
	grpc.ClientStream
}

func (x *transactionServerSubscribeTransactionsClient) Recv() (*Transaction, error) {
	m := new(Transaction)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for TransactionServer service

type TransactionServerServer interface {
	// Obtain top transaction from given time-frame of given asset as an rpc stream
	TopTransactions(*CryptoTransactionRequest, TransactionServer_TopTransactionsServer) error
	// Obtain historic transactions from given time-frame of given asset as an array
	HistoricTransactions(*CryptoTransactionRequest, TransactionServer_HistoricTransactionsServer) error
	// subscribe to the newest transactions of given asset
	SubscribeTransactions(*CryptoSubscribeRequest, TransactionServer_SubscribeTransactionsServer) error
}

func RegisterTransactionServerServer(s *grpc.Server, srv TransactionServerServer) {
	s.RegisterService(&_TransactionServer_serviceDesc, srv)
}

func _TransactionServer_TopTransactions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CryptoTransactionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TransactionServerServer).TopTransactions(m, &transactionServerTopTransactionsServer{stream})
}

type TransactionServer_TopTransactionsServer interface {
	Send(*Transaction) error
	grpc.ServerStream
}

type transactionServerTopTransactionsServer struct {
	grpc.ServerStream
}

func (x *transactionServerTopTransactionsServer) Send(m *Transaction) error {
	return x.ServerStream.SendMsg(m)
}

func _TransactionServer_HistoricTransactions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CryptoTransactionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TransactionServerServer).HistoricTransactions(m, &transactionServerHistoricTransactionsServer{stream})
}

type TransactionServer_HistoricTransactionsServer interface {
	Send(*Transaction) error
	grpc.ServerStream
}

type transactionServerHistoricTransactionsServer struct {
	grpc.ServerStream
}

func (x *transactionServerHistoricTransactionsServer) Send(m *Transaction) error {
	return x.ServerStream.SendMsg(m)
}

func _TransactionServer_SubscribeTransactions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CryptoSubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TransactionServerServer).SubscribeTransactions(m, &transactionServerSubscribeTransactionsServer{stream})
}

type TransactionServer_SubscribeTransactionsServer interface {
	Send(*Transaction) error
	grpc.ServerStream
}

type transactionServerSubscribeTransactionsServer struct {
	grpc.ServerStream
}

func (x *transactionServerSubscribeTransactionsServer) Send(m *Transaction) error {
	return x.ServerStream.SendMsg(m)
}

var _TransactionServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "types.TransactionServer",
	HandlerType: (*TransactionServerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "TopTransactions",
			Handler:       _TransactionServer_TopTransactions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "HistoricTransactions",
			Handler:       _TransactionServer_HistoricTransactions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeTransactions",
			Handler:       _TransactionServer_SubscribeTransactions_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "types.proto",
}

func init() { proto.RegisterFile("types.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 500 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x52, 0xc1, 0x6e, 0x13, 0x31,
	0x10, 0x95, 0xb3, 0xd9, 0x84, 0x4c, 0x8a, 0x00, 0x13, 0x2a, 0x13, 0x51, 0x35, 0xec, 0x01, 0x45,
	0x1c, 0xb6, 0x28, 0x9c, 0x39, 0xd1, 0x4a, 0x15, 0x2a, 0x17, 0x27, 0xbd, 0x21, 0x21, 0x27, 0x71,
	0x1b, 0x8b, 0xec, 0x7a, 0xb1, 0xbd, 0x48, 0xcb, 0xc7, 0xf1, 0x61, 0x88, 0x03, 0xf2, 0x78, 0x37,
	0x6c, 0x50, 0x4a, 0x2f, 0xdc, 0x66, 0xde, 0x8c, 0xde, 0x3c, 0x3f, 0x3f, 0x18, 0xba, 0xaa, 0x90,
	0x36, 0x2d, 0x8c, 0x76, 0x9a, 0xc6, 0xd8, 0x8c, 0x4f, 0x6f, 0xb5, 0xbe, 0xdd, 0xca, 0x33, 0x04,
	0x97, 0xe5, 0xcd, 0x99, 0x53, 0x99, 0xb4, 0x4e, 0x64, 0x45, 0xd8, 0x4b, 0x7e, 0x11, 0x18, 0x2e,
	0x8c, 0xc8, 0xad, 0x58, 0x39, 0xa5, 0x73, 0x4a, 0xa1, 0xbb, 0x11, 0x76, 0xc3, 0x3a, 0x13, 0x32,
	0x1d, 0x70, 0xac, 0xe9, 0x4b, 0xe8, 0xde, 0x18, 0x9d, 0xb1, 0x68, 0x42, 0xa6, 0xc3, 0xd9, 0xc3,
	0x34, 0xdc, 0xb9, 0xc8, 0x9d, 0x72, 0x15, 0xc7, 0x11, 0x3d, 0x81, 0x8e, 0xd3, 0xac, 0x7b, 0x68,
	0xa1, 0xe3, 0x34, 0x4d, 0xa1, 0xeb, 0x0f, 0xb3, 0x3e, 0x2e, 0x8c, 0xd3, 0xa0, 0x2a, 0x6d, 0x54,
	0xa5, 0x8b, 0x46, 0x15, 0xc7, 0x3d, 0x3a, 0x82, 0x58, 0x58, 0x2b, 0x1d, 0x1b, 0xa0, 0x8c, 0xd0,
	0x78, 0x6d, 0x56, 0x7d, 0x97, 0x0c, 0x26, 0x64, 0x4a, 0x38, 0xd6, 0xf4, 0x39, 0x3c, 0xb8, 0x9e,
	0x9f, 0x7f, 0x46, 0x7c, 0x88, 0x78, 0xff, 0x7a, 0x7e, 0x3e, 0xf7, 0xa3, 0x04, 0x62, 0xa7, 0xbf,
	0xc8, 0x9c, 0x1d, 0xe1, 0xd5, 0xa3, 0x5a, 0xd6, 0xc2, 0x63, 0x3c, 0x8c, 0x92, 0x4f, 0xd0, 0x0b,
	0x32, 0x29, 0x83, 0xbe, 0x58, 0xaf, 0x8d, 0xb4, 0x96, 0x11, 0x3c, 0xda, 0xb4, 0xfe, 0x6c, 0x2e,
	0x32, 0xd9, 0x58, 0xe2, 0x6b, 0x8f, 0x79, 0x36, 0xb4, 0x64, 0xc0, 0xb1, 0xa6, 0x8f, 0x21, 0x2a,
	0xcd, 0x16, 0x4d, 0x18, 0x70, 0x5f, 0x26, 0x02, 0x62, 0xbc, 0xb6, 0xa3, 0x20, 0x2d, 0x8a, 0x11,
	0xc4, 0xab, 0x8d, 0x50, 0x79, 0xcd, 0x1b, 0x1a, 0x7a, 0x0c, 0x3d, 0x5b, 0x65, 0x4b, 0xbd, 0xad,
	0xa9, 0xeb, 0xce, 0xe3, 0xe1, 0x87, 0x6a, 0xfe, 0xba, 0x4b, 0xfa, 0x10, 0x5f, 0x64, 0x85, 0xab,
	0x92, 0x0f, 0x70, 0xfc, 0xde, 0x54, 0x85, 0xd3, 0xf3, 0x72, 0x69, 0x57, 0x46, 0x2d, 0x25, 0x97,
	0x5f, 0x4b, 0x69, 0xdd, 0x4e, 0x2b, 0x69, 0x69, 0x7d, 0x01, 0x03, 0x6f, 0xd9, 0x95, 0xca, 0x94,
	0x63, 0xf1, 0x84, 0x4c, 0x23, 0xfe, 0x07, 0x48, 0xde, 0xc1, 0xd3, 0x56, 0x26, 0xb8, 0xb4, 0x85,
	0xce, 0xad, 0xa4, 0xaf, 0xa0, 0xbb, 0x16, 0x4e, 0x30, 0x32, 0x89, 0xa6, 0xc3, 0x19, 0x6d, 0xfc,
	0x6c, 0x6d, 0xe2, 0x3c, 0xf9, 0x41, 0x80, 0x05, 0x2d, 0x7b, 0x2c, 0x77, 0xab, 0x49, 0xeb, 0x80,
	0x75, 0xee, 0x8f, 0x07, 0xa6, 0xed, 0x35, 0xa6, 0x2d, 0xba, 0x77, 0xdb, 0x47, 0xcf, 0xdb, 0xac,
	0xcb, 0xdc, 0xa1, 0x6f, 0x11, 0x0f, 0xcd, 0xbf, 0xdf, 0x3f, 0xfb, 0x49, 0xe0, 0x49, 0x4b, 0xfa,
	0x5c, 0x9a, 0x6f, 0xd2, 0xd0, 0x4b, 0x78, 0xb4, 0xd0, 0x45, 0x0b, 0xb7, 0xf4, 0xb4, 0xf6, 0xe0,
	0xae, 0xd7, 0x8e, 0x0f, 0x98, 0xf4, 0x86, 0xd0, 0x8f, 0x30, 0xba, 0x54, 0xd6, 0x69, 0xa3, 0x56,
	0xff, 0x83, 0xee, 0x0a, 0x9e, 0xed, 0x3e, 0x7d, 0x8f, 0xef, 0x64, 0x8f, 0xef, 0xef, 0x60, 0x1c,
	0x66, 0x5b, 0xf6, 0xd0, 0xc8, 0xb7, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x09, 0xff, 0x22, 0x62,
	0x4f, 0x04, 0x00, 0x00,
}
